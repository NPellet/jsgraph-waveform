{"version":3,"file":null,"sources":["/Users/normanpellet/Documents/Web/graph/src/util/fit_lm.js","/Users/normanpellet/Documents/Web/graph/src/util/waveform.js"],"sourcesContent":["class FitHost {\n\n  constructor( options ) {\n\n    this.DELTAP = 1e-6;\n    this.BIGVAL = 9e99;\n    this.WEIGHT = 1.0;\n\n    this.setYData( options.dataY );\n    this.setXData( options.dataX );\n    this.setWeight( options.weight );\n    this.setInitialParams( options.params );\n\n    if ( options.subsetIndex ) {\n      this.setSubset( ...options.subsetIndex );\n    }\n\n    this.setFunction( options.function );\n\n    if ( options.progress ) {\n      this.hookIteration( options.progress );\n    }\n\n    this.options = options;\n  }\n\n  //[ [ x1, y1 ], [ x2, y2 ] ]\n  setYData( data ) { // Waveform instance\n    this.data = data;\n  }\n\n  setXData( data ) { // Waveform instance\n    this.dataX = data;\n  }\n\n  setWeight( weight ) { // Waveform instance\n    this.weight = weight;\n  }\n\n  setInitialParams( params ) {\n    this.parms = params;\n\n    this.parms = this.parms.map( ( el ) => {\n      if ( typeof el == 'function' ) {\n        return el( this.data, this.dataX );\n      } else {\n        return el;\n      }\n    } );\n    this.NPARMS = params.length;\n  }\n\n  setSubset( fromIndex, toIndex ) {\n    if ( fromIndex !== undefined && toIndex !== undefined ) {\n      this._from = fromIndex;\n      this._to = toIndex;\n    }\n  }\n\n  hookIteration( f ) {\n    this._hookIteration = ( params ) => {\n      let data = this.buildFit( params, 200 );\n      f( data );\n    };\n  }\n\n  setFunction( func ) {\n    this._func = func;\n  }\n\n  init() {\n\n    // Get data length\n    if ( this._from !== undefined && this._to !== undefined ) {\n\n      if ( this._from >= this._to ) {\n        throw 'Impossible to fit negative subranges. The starting index must be lower than the ending index';\n      }\n\n      this.NPTS = this._to - this._from + 1;\n\n      if ( this.data && this.data.getLength() <= this._to ) {\n        throw 'Wave Y has not enough point to be fitted to subrange [' + this._from + ', ' + this._to + ']';\n      }\n\n      if ( this._from < 0 ) {\n        throw 'Impossible to fit a subrange with negative indices';\n      }\n\n    } else {\n\n      this.NPTS = this.data.getLength();\n      this._from = 0;\n      this._to = this.data.getLength() - 1;\n    }\n\n    if ( this.dataX && this.dataX.getLength() <= this._to ) {\n      throw 'Wave X has not enough point to be fitted to subrange [' + this._from + ', ' + this._to + ']';\n    }\n\n    this.arrY = this.data.getDataY();\n\n    if ( this.dataX ) {\n      this.arrX = this.dataX.getDataY();\n    } else {\n      this.arrX = this.data.getDataX();\n    }\n\n    this.resid = new Array( this.NPTS ).fill( 0 );\n    this.jac = new Array( this.NPTS ).fill( 0 );\n    this.jac = this.jac.map( ( el ) => new Array( this.NPARMS ) );\n  }\n\n  fit() {\n\n    this.log( 'Starting the fit with initial parameter list {' + this.parms.join() + '};' );\n    new LM( this, this.NPARMS, this.NPTS, this._hookIteration );\n    this.log( 'Fit successful. Output parameters {' + this.parms.join() + '};' );\n\n    this._result = this.buildFit( this.parms, 200 );\n\n    if ( this.options.done ) {\n      this.options.done( this.parms, this._result );\n    }\n\n    return this._result;\n  }\n\n  func( x, param ) {\n    return this._func( x, param );\n  }\n\n  computeResiduals() {\n    var sumsq = 0;\n    for ( var i = 0; i < this.NPTS; i++ ) {\n      this.resid[ i ] = ( this.func( this.arrX[ i + this._from ], this.parms ) - this.arrY[ i + this._from ] ) * ( this.WEIGHT );\n      sumsq += this.resid[ i ] * this.resid[ i ];\n    }\n\n    return sumsq;\n  }\n\n  log( message ) {\n    if ( this.options.log ) {\n      console.log( message );\n    }\n  }\n\n  //------the four mandated interface methods------------\n  nudge( dp ) {\n\n    for ( var j = 0; j < this.NPARMS; j++ ) {\n      this.parms[ j ] += dp[ j ];\n    }\n    return this.computeResiduals();\n  }\n\n  buildJacobian() {\n    // Allows LM to compute a new Jacobian.\n    // Uses current parms[] and two-sided finite difference.\n    // If current parms[] is bad, returns false.\n    var delta = new Array( this.NPARMS );\n    var FACTOR = 0.5 / this.DELTAP;\n    var d = 0;\n\n    for ( var j = 0; j < this.NPARMS; j++ ) {\n      for ( var k = 0; k < this.NPARMS; k++ )\n        delta[ k ] = ( k == j ) ? this.DELTAP : 0.0;\n\n      d = this.nudge( delta ); // resid at pplus\n      if ( d == this.BIGVAL ) {\n        throw 'Bad dBuildJacobian() exit 2';\n      }\n\n      for ( var i = 0; i < this.NPTS; i++ ) {\n        this.jac[ i ][ j ] = this.getResidualElement( i );\n      }\n\n      for ( var k = 0; k < this.NPARMS; k++ ) {\n        delta[ k ] = ( k == j ) ? -2 * this.DELTAP : 0.0;\n      }\n\n      d = this.nudge( delta ); // resid at pminus\n      if ( d == this.BIGVAL ) {\n        throw 'Bad dBuildJacobian(). exit 3';\n      }\n\n      for ( var i = 0; i < this.NPTS; i++ )\n        this.jac[ i ][ j ] -= this.getResidualElement( i ); // fetches resid[]\n\n      for ( var i = 0; i < this.NPTS; i++ )\n        this.jac[ i ][ j ] *= FACTOR;\n\n      for ( var k = 0; k < this.NPARMS; k++ )\n        delta[ k ] = ( k == j ) ? this.DELTAP : 0.0;\n\n      d = this.nudge( delta );\n      if ( d == this.BIGVAL ) {\n        throw 'Bad dBuildJacobian(). exit 4';\n      }\n    }\n    return true;\n  }\n\n  getResidualElement( i ) {\n    // Allows LM to see one element of the resid[] vector.\n    return this.resid[ i ];\n  }\n\n  getJacobianElement( i, j ) {\n    // Allows LM to see one element of the Jacobian matrix.\n    return this.jac[ i ][ j ];\n  }\n\n  buildFit( parms, length ) {\n    let x;\n\n    if ( !length ) {\n      x = this.arrX;\n    } else {\n\n      const xmin = ( this.dataX ).getMin( this._from, this._to );\n      const xmax = ( this.dataX ).getMax( this._from, this._to );\n\n      x = new Array( length ).fill( 0 ).map( ( el, index ) => index * ( xmax - xmin ) / ( length - 1 ) + xmin );\n    }\n\n    var fit = new Array( x.length );\n    for ( var i = 0, l = x.length; i < l; i++ ) {\n      fit[ i ] = this.func( x[ i ], this.parms );\n    }\n\n    let waveformResult = this.options.waveform;\n    waveformResult.setData( fit, x );\n    //waveformResult.setXWaveform( x );\n\n    return waveformResult;\n  }\n}\n\nclass LM {\n\n  constructor( gH, gnadj, gnpnts, hook ) {\n\n    this.LMITER = 100; // max number of L-M iterations\n    this.LMBOOST = 2.0; // damping increase per failed step\n    this.LMSHRINK = 0.10; // damping decrease per successful step\n    this.LAMBDAZERO = 0.001; // initial damping\n    this.LAMBDAMAX = 1E9; // max damping\n    this.LMTOL = 1E-12; // exit tolerance\n    this.BIGVAL = 9e99; // trouble flag\n\n    this.sos;\n    this.sosprev;\n    this.lambda;\n\n    this.myH = null; // overwritten by constructor\n    this.nadj = 0; // overwritten by constructor\n    this.npts = 0; // overwritten by constructor\n\n    this.delta; // local parm change\n    this.beta;\n    this.alpha;\n    this.amatrix;\n\n    // Constructor sets up fields and drives iterations.\n    this.myH = gH;\n    this.nadj = gnadj;\n    this.npts = gnpnts;\n\n    this.delta = new Array( this.nadj ).fill( 0 );\n    this.beta = new Array( this.nadj ).fill( 0 );\n\n    this.alpha = new Array( this.nadj ).fill( 0 );\n    this.amatrix = new Array( this.nadj ).fill( 0 );\n\n    this.alpha = this.alpha.map( () => new Array( this.nadj ) );\n    this.amatrix = this.amatrix.map( () => new Array( this.nadj ) );\n\n    this.lambda = this.LAMBDAZERO;\n\n    var niter = 0;\n    var done = false;\n    do {\n      done = this.bLMiter();\n\n      if ( hook ) {\n        hook( this.myH.params );\n      }\n\n      niter++;\n    }\n    while ( !done && ( niter < this.LMITER ) );\n  }\n\n  bLMiter() {\n    // Each call performs one LM iteration.\n    // Returns true if done with iterations; false=wants more.\n    // Global nadj, npts; needs nadj, myH to be preset.\n    // Ref: M.Lampton, Computers in Physics v.11 pp.110-115 1997.\n    for ( var k = 0; k < this.nadj; k++ )\n      this.delta[ k ] = 0.0;\n    this.sos = this.myH.nudge( this.delta );\n    if ( this.sos == this.BIGVAL ) {\n      console.error( '  bLMiter finds faulty initial nudge()' );\n      return false;\n    }\n    this.sosprev = this.sos;\n\n    this.myH.log( '  bLMiter..SumOfSquares= ' + this.sos );\n    if ( !this.myH.buildJacobian() ) {\n      console.error( '  bLMiter finds buildJacobian()=false' );\n      return false;\n    }\n\n    for ( var k = 0; k < this.nadj; k++ ) // get downhill gradient beta\n    {\n      this.beta[ k ] = 0.0;\n      for ( var i = 0; i < this.npts; i++ ) {\n        this.beta[ k ] -= this.myH.getResidualElement( i ) * this.myH.getJacobianElement( i, k );\n      }\n    }\n\n    for ( var k = 0; k < this.nadj; k++ ) // get curvature matrix alpha\n      for ( var j = 0; j < this.nadj; j++ ) {\n        this.alpha[ j ][ k ] = 0.0;\n        for ( var i = 0; i < this.npts; i++ ) {\n          this.alpha[ j ][ k ] += this.myH.getJacobianElement( i, j ) * this.myH.getJacobianElement( i, k );\n        }\n      }\n    var rrise = 0;\n    do // inner damping loop searches for one downhill step\n    {\n      for ( var k = 0; k < this.nadj; k++ ) { // copy and damp it\n        for ( var j = 0; j < this.nadj; j++ ) {\n          this.amatrix[ j ][ k ] = this.alpha[ j ][ k ] + ( ( j == k ) ? this.lambda : 0.0 );\n        }\n      }\n\n      this.gaussj( this.amatrix, this.nadj ); // invert\n\n      for ( var k = 0; k < this.nadj; k++ ) // compute delta[]\n      {\n        this.delta[ k ] = 0.0;\n        for ( var j = 0; j < this.nadj; j++ )\n          this.delta[ k ] += this.amatrix[ j ][ k ] * this.beta[ j ];\n      }\n      this.sos = this.myH.nudge( this.delta ); // try it out.\n      if ( this.sos == this.BIGVAL ) {\n        console.error( '  LMinner failed SOS step' );\n        return false;\n      }\n      rrise = ( this.sos - this.sosprev ) / ( 1 + this.sos );\n      if ( rrise <= 0.0 ) // good step!\n      {\n        this.lambda *= this.LMSHRINK; // shrink lambda\n        break; // leave lmInner.\n      }\n      for ( var q = 0; q < this.nadj; q++ ) { // reverse course!\n        this.delta[ q ] *= -1.0;\n      }\n      this.myH.nudge( this.delta ); // sosprev should still be OK\n      if ( rrise < this.LMTOL ) { // finished but keep prev parms\n        break; // leave inner loop\n      }\n      this.lambda *= this.LMBOOST; // else try more damping.\n    } while ( this.lambda < this.LAMBDAMAX );\n    return ( rrise > -this.LMTOL ) || ( this.lambda > this.LAMBDAMAX );\n  }\n\n  gaussj( a, N ) {\n    // Inverts the double array a[N][N] by Gauss-Jordan method\n    // M.Lampton UCB SSL (c)2003, 2005\n\n    var det = 1.0,\n      big, save;\n    var i, j, k, L;\n    var ik = new Array( 100 );\n    var jk = new Array( 100 );\n\n    for ( k = 0; k < N; k++ ) {\n      big = 0.0;\n      for ( i = k; i < N; i++ )\n        for ( j = k; j < N; j++ ) // find biggest element\n          if ( Math.abs( big ) <= Math.abs( a[ i ][ j ] ) ) {\n            big = a[ i ][ j ];\n            ik[ k ] = i;\n            jk[ k ] = j;\n          }\n      if ( big == 0.0 ) return 0.0;\n      i = ik[ k ];\n      if ( i > k )\n        for ( j = 0; j < N; j++ ) // exchange rows\n      {\n        save = a[ k ][ j ];\n        a[ k ][ j ] = a[ i ][ j ];\n        a[ i ][ j ] = -save;\n      }\n      j = jk[ k ];\n      if ( j > k )\n        for ( i = 0; i < N; i++ ) {\n          save = a[ i ][ k ];\n          a[ i ][ k ] = a[ i ][ j ];\n          a[ i ][ j ] = -save;\n        }\n      for ( i = 0; i < N; i++ ) // build the inverse\n        if ( i != k )\n          a[ i ][ k ] = -a[ i ][ k ] / big;\n      for ( i = 0; i < N; i++ )\n        for ( j = 0; j < N; j++ )\n          if ( ( i != k ) && ( j != k ) )\n            a[ i ][ j ] += a[ i ][ k ] * a[ k ][ j ];\n      for ( j = 0; j < N; j++ )\n        if ( j != k )\n          a[ k ][ j ] /= big;\n      a[ k ][ k ] = 1.0 / big;\n      det *= big; // bomb point\n    } // end k loop\n    for ( L = 0; L < N; L++ ) {\n      k = N - L - 1;\n      j = ik[ k ];\n      if ( j > k )\n        for ( i = 0; i < N; i++ ) {\n          save = a[ i ][ k ];\n          a[ i ][ k ] = -a[ i ][ j ];\n          a[ i ][ j ] = save;\n        }\n      i = jk[ k ];\n      if ( i > k )\n        for ( j = 0; j < N; j++ ) {\n          save = a[ k ][ j ];\n          a[ k ][ j ] = -a[ i ][ j ];\n          a[ i ][ j ] = save;\n        }\n    }\n    return det;\n  }\n}\n\nexport default FitHost;\n//module.export = FitHost","import FitLM from './fit_lm';\nimport extend from 'extend';\n\nclass Waveform {\n\n  constructor( data = [], xOffset = 0, xScale = 1 ) {\n\n    this.xOffset = xOffset;\n    this.xScale = xScale;\n    this.setData( data );\n  }\n\n  /** [ [ x1, y1 ], [ x2, y2 ] ] */\n\n  /*\n  setDataXY( data ) {\n\n    let newData = [ this._makeArray( data.length ), this._makeArray( data.length ) ],\n      warnNaN = false;\n    const nanable = this.isNaNAllowed();\n\n    data.map( ( el, index ) => {\n\n      if ( !nanable && ( el[ 0 ] !== el[ 0 ] || el[ 1 ] !== el[ 1 ] ) ) {\n        warnNaN = true;\n      }\n\n      newData[ 0 ][ index ] = el[ 0 ];\n      newData[ 1 ][ index ] = el[ 1 ];\n    } );\n\n    if ( warnNaN ) {\n      this.warn( \"Trying to assign NaN values to a typed array that does not support NaNs. 0's will be used instead\" );\n    }\n\n    this._setData( ...newData );\n    return this;\n  }\n*/\n  setData( data, dataX = null ) {\n\n    /* First, we must treat the case of the array of array for backward compatibility */\n    if ( Array.isArray( data[ 0 ] ) ) {\n      let x = [];\n      let y = [];\n      data.forEach( ( el ) => {\n        x.push( el[ 0 ] );\n        y.push( el[ 1 ] );\n      } );\n\n      this.setXWaveform( x );\n      data = y;\n    }\n\n    let newData = this._makeArray( data.length ),\n      warnNaN = false;\n\n    const nanable = this.isNaNAllowed();\n\n    data.map( ( el, index ) => {\n\n      if ( !nanable && ( el[ 0 ] !== el[ 0 ] || el[ 1 ] !== el[ 1 ] ) ) {\n        warnNaN = true;\n      }\n\n      newData[ index ] = el;\n    } );\n\n    if ( warnNaN ) {\n      this.warn( \"Trying to assign NaN values to a typed array that does not support NaNs. 0's will be used instead\" );\n    }\n\n    this._setData( newData );\n\n    if ( dataX ) {\n      this.setXWaveform( dataX );\n    }\n    return this;\n  }\n\n  getY( index, optimized ) {\n\n    if ( optimized && this.dataInUse ) {\n      return this.dataInUse.y[ index ] * this.getScale() + this.getShift();\n    }\n\n    return this.data[ index ] * this.getScale() + this.getShift();\n  }\n\n  /*\n    flipXY() {\n      let temp;\n      temp = this.data.x;\n      this.data.x = this.data.y;\n      this.data.y = temp;\n\n      this._setData( this.data.x, this.data.y );\n    }*/\n\n  setXWaveform( waveform ) {\n\n    if ( !( waveform instanceof Waveform ) ) {\n\n      if ( Array.isArray( waveform ) ) {\n        waveform = new Waveform( waveform );\n      } else {\n        throw \"Cannot set X waveform. Data is not a valid array.\"\n      }\n    }\n\n    this.xdata = waveform;\n    this.computeXMinMax();\n    return this;\n  }\n\n  hasXWaveform() {\n    return !!this.xdata;\n  }\n\n  getXWaveform() {\n    if ( this.xdata ) {\n      return this.xdata;\n    }\n\n    var wave = new Waveform();\n    for ( var i = 0; i < this.getLength(); i += 1 ) {\n      wave.append( this.getX( i ) );\n    }\n    return wave;\n  }\n\n  rescaleX( offset, scale ) {\n    this.xScale = scale;\n    this.xOffset = offset;\n    this.computeXMinMax();\n    return this;\n  }\n\n  getTypedArrayClass() {\n    return this._typedArrayClass || false;\n  }\n\n  setTypedArrayClass( constructor ) {\n\n    if ( this.getTypedArrayClass() && this.isNaNAllowed() && !this.isNaNAllowed( constructor ) ) {\n      this.warn( \"NaN values are not allowed by the new constructor (\" + constructor.name + \") while it was allowed by the previous one (\" + this._typedArrayClass.name + \")\" );\n    }\n\n    if ( this.getTypedArrayClass() && this.isUnsigned() && !this.isUnsigned( constructor ) ) {\n      this.warn( \"You are switching from signed values to unsigned values. You may experience data corruption if there were some negative values.\" );\n    }\n\n    this._typedArrayClass = constructor;\n\n    if ( this.data ) {\n      this._setData( ( constructor ).from( this.data ) );\n    }\n\n    if ( this.hasXWaveform() ) {\n      this.getXWaveform().setTypedArrayClass( constructor );\n    }\n\n  }\n\n  isNaNAllowed( constructor = this._typedArrayClass ) {\n\n    // The following types accept NaNs\n    return constructor == Array ||\n      constructor == Float32Array ||\n      constructor == Float64Array;\n  }\n\n  isUnsigned( constructor = this._typedArrayClass ) {\n\n    // The following types accept NaNs\n    return constructor == Uint8Array ||\n      constructor == Uint8ClampedArray ||\n      constructor == Uint16Array ||\n      constructor == Uint32Array;\n  }\n\n  recalculateMinMaxNewPoint( x, y ) {\n    if ( x < this.minX || this.minX === undefined ) {\n      this.minX = x;\n    }\n\n    if ( x > this.maxX || this.maxX === undefined ) {\n      this.maxX = x;\n    }\n\n    if ( y < this.minY || this.minY === undefined ) {\n      this.minY = y;\n    }\n\n    if ( y > this.maxY || this.maxY === undefined ) {\n      this.maxY = y;\n    }\n\n  }\n\n  prepend( x, y ) {\n\n    if ( typeof x == \"function\" ) {\n      x = x( this );\n    }\n\n    if ( typeof y == \"function\" ) {\n      y = y( this );\n    }\n\n    if ( this.xdata ) {\n      this.xdata.prepend( null, x );\n    } else if ( x !== null ) {\n      this.xdata = this.getXWaveform();\n      this.xdata.prepend( null, x );\n    } else {\n      this.xOffset -= this.xScale;\n    }\n\n    this.data.unshift( y );\n    this.recalculateMinMaxNewPoint( x, y );\n    return this;\n  }\n\n  append( x, y ) {\n\n    if ( typeof x == \"function\" ) {\n      x = x( this );\n    }\n\n    if ( typeof y == \"function\" ) {\n      y = y( this );\n    }\n\n    if ( this.xdata ) {\n      this.xdata.append( null, x );\n    } else if ( x !== null ) {\n      this.xdata = this.getXWaveform();\n      this.xdata.append( null, x );\n    }\n\n    if ( this.monotoneous ) {\n      if ( y > this.data[ this.data.y ] && this.getMonotoneousAscending() === false ) {\n        this.monotoneous = false;\n      } else if ( y < this.data[ this.data.y ] && this.getMonotoneousAscending() === true ) {\n        this.monotoneous = false;\n      }\n    }\n\n    if ( this.data.length == 1 || this._monotoneousAscending === undefined ) {\n\n      this.monotoneous = true;\n\n      if ( y == this.data[ 0 ] ) {\n        this._monotoneousAscending = undefined;\n      } else {\n        this._monotoneousAscending = y > this.data[ 0 ];\n      }\n    }\n\n    this.data.push( y );\n    this.recalculateMinMaxNewPoint( x, y );\n\n    return this;\n  }\n\n  _makeArray( length ) {\n\n    const constructor = this.getTypedArrayClass();\n    if ( constructor ) {\n      return new( constructor )( length );\n    }\n    return new Array( length );\n  }\n\n  _setData( dataY ) {\n    const l = dataY.length;\n    let i = 1,\n      monoDir = dataY[ 1 ] > dataY[ 0 ],\n      minY = dataY[ 0 ],\n      maxY = dataY[ 0 ];\n\n    this._monotoneous = true;\n\n    for ( ; i < l; i++ ) {\n      if ( dataY[ i ] !== dataY[ i - 1 ] && monoDir !== ( dataY[ i ] > dataY[ i - 1 ] ) ) {\n        this._monotoneous = false;\n      }\n\n      if ( dataY[ i ] === dataY[ i ] ) { // NaN support\n        minY = Math.min( dataY[ i ], minY );\n        maxY = Math.max( dataY[ i ], maxY );\n      }\n    }\n\n    if ( this._monotoneous ) {\n      this._monotoneousAscending = dataY[ 1 ] > dataY[ 0 ];\n    }\n\n    this.minY = minY;\n    this.maxY = maxY;\n\n    this.data = dataY;\n\n    this.computeXMinMax();\n\n  }\n\n  computeXMinMax() {\n\n    if ( !this.data ) {\n\n      return;\n    }\n\n    if ( this.xdata ) {\n\n      this.minX = this.xdata.getMin();\n      this.maxX = this.xdata.getMax();\n\n    } else {\n\n      const b1 = this.xOffset + this.xScale * this.getLength(),\n        b2 = this.xOffset;\n\n      this.minX = Math.min( b1, b2 );\n      this.maxX = Math.max( b1, b2 );\n    }\n  }\n\n  getDataInUse() {\n    return this.dataInUse ||  this.data;\n  }\n\n  getIndexFromVal( val, useDataToUse = false, roundingMethod = Math.round ) {\n\n    let data;\n\n    if ( useDataToUse && this.dataInUse ) {\n      data = this.dataInUse.y;\n    } else {\n      data = this.data;\n    }\n\n    let position;\n\n    position = this.getIndexFromData( val, data, this.data.getMonotoneousAscending(), roundingMethod );\n\n    if ( useDataToUse && this.dataInUse && this.dataInUseType == \"aggregateY\" ) { // In case of aggregation, round to the closest element of 4.\n      return position - ( position % 4 );\n    }\n\n    return position;\n  }\n\n  getIndexFromX( xval, useDataToUse = false, roundingMethod = Math.round ) {\n\n    let xdata;\n\n    if ( useDataToUse && this.dataInUse ) {\n      xdata = this.dataInUse.x;\n    } else if ( this.xdata ) {\n      xdata = this.xdata.getData();\n    }\n\n    let position;\n\n    if ( this.hasXWaveform() ) {\n      position = this.xdata.getIndexFromData( xval, xdata, this.xdata.getMonotoneousAscending(), roundingMethod );\n    } else {\n      position = Math.max( 0, Math.min( this.getLength() - 1, roundingMethod( ( xval - this.xOffset ) / ( this.xScale ) ) ) );\n    }\n\n    if ( useDataToUse && this.dataInUse && this.dataInUseType == \"aggregateX\" ) { // In case of aggregation, round to the closest element of 4.\n      return position - ( position % 4 );\n    }\n\n    return position;\n  }\n\n  getIndexFromData( val, valCollection, isAscending, roundingMethod ) {\n\n    if ( !this.isMonotoneous() ) {\n      console.trace();\n      throw \"Impossible to get the index from a non-monotoneous wave !\"\n    }\n\n    let data, position;\n\n    val -= this.getShift();\n    val /= this.getScale();\n\n    return binarySearch( val, valCollection, !isAscending );\n\n  }\n\n  getReductionType() {\n    return this.dataInUseType;\n  }\n\n  getXMin() {\n    return this.minX * this.getXScale() + this.getXShift();\n  }\n\n  getXMax() {\n    return this.maxX * this.getXScale() + this.getXShift();\n  }\n\n  getYMin() {\n    return this.minY * this.getScale() + this.getShift();\n  }\n\n  getYMax() {\n    return this.maxY * this.getScale() + this.getShift();\n  }\n\n  getMin() {\n    return this.minY * this.getScale() + this.getShift();\n  }\n\n  getMax() {\n    return this.maxY * this.getScale() + this.getShift();\n  }\n\n  getMinX() {\n\n    return this.minX * this.getXScale() + this.getXShift();\n  }\n\n  getMaxX() {\n    return this.maxX * this.getXScale() + this.getXShift();\n  }\n\n  getMinY() {\n    return this.minY * this.getScale() + this.getShift();\n  }\n\n  getMaxY() {\n    return this.maxY * this.getScale() + this.getShift();\n  }\n\n  getDataY() {\n    return this.data;\n  }\n\n  getData( optimized ) {\n    if ( !optimized ||  !this.dataInUse ) {\n      return this.data;\n    }\n    return this.dataInUse.y;\n  }\n\n  setShift( shift = 0 ) {\n\n    // We must update the min and the max of the y data\n    //this.minY += ( shift - this.getShift() );\n    //this.maxY += ( shift - this.getShift() );\n    this.shift = shift;\n    return this;\n  }\n\n  getShift() {\n    return this.shift ||  0;\n  }\n\n  getScale() {\n    return this.scale ||  1;\n  }\n\n  setScale( scale = 1 ) {\n\n    // this.minY = ( this.minY - this.getShift() ) * scale;\n    // this.maxY = ( this.maxY - this.getShift() ) * scale;\n    this.scale = scale;\n    return this;\n  }\n\n  setXShift( shift = 0 ) {\n\n    if ( !this.hasXWaveform ) {\n      return this;\n    }\n\n    // We must update the min and the max of the x data\n    // That's important for when the data has already been set\n    //  this.minX += ( shift - this.getXShift() );\n    //    this.maxX += ( shift - this.getXShift() );\n    this.getXWaveform().setShift( shift );\n    return this;\n  }\n\n  getXShift( shift = 0 ) {\n\n    if ( !this.hasXWaveform ) {\n      return 0;\n    }\n\n    return this.getXWaveform().getShift();\n  }\n\n  setXScale( scale = 1 ) {\n\n    if ( !this.hasXWaveform ) {\n      return this;\n    }\n\n    this.getXWaveform().setScale( scale );\n    return this;\n  }\n\n  getXScale() {\n\n    if ( !this.hasXWaveform ) {\n      return 1;\n    }\n\n    return this.getXWaveform().getScale();\n  }\n\n  getLength() {\n    return this.data.length;\n  }\n\n  getDataToUseFlat() {\n\n    let l;\n    let j = 0;\n    let arr;\n\n    if ( this.dataInUse ) {\n\n      l = this.dataInUse.x.length;\n      arr = new Array( l * 2 ).fill( 0 );\n\n      for ( var i = 0; i < l; i += 1 ) {\n        arr[ j ] = this.dataInUse.x[ i ];\n        arr[ j + 1 ] = this.dataInUse.y[ i ];\n        j += 2;\n      }\n\n    } else {\n\n      l = this.getLength();\n      arr = new Array( l * 2 ).fill( 0 );\n      for ( var i = 0; i < l; i += 1 ) {\n        arr[ j + 1 ] = this.data[ i ];\n        arr[ j ] = this.getX( i );\n        j += 2;\n      }\n    }\n\n    return arr;\n  }\n\n  fit( options ) {\n\n    var self = this;\n\n    return new Promise( function( resolver, rejector ) {\n\n      var fit = new FitLM( extend( {}, {\n\n        dataY: self,\n        dataX: self.getXWaveform(),\n        done: function( results ) {\n          resolver( results );\n        },\n        waveform: new Waveform()\n\n      }, options ) );\n\n      fit.init();\n      fit.fit();\n    } );\n  }\n\n  getX( index, optimized ) {\n\n    if ( optimized && this.dataInUse ) {\n      return this.dataInUse.x[ index ] * this.getXScale() + this.getXShift();\n    }\n\n    if ( this.xdata ) {\n      return this.xdata.data[ index ] * this.getXScale() + this.getXShift();\n    } else {\n      return this.xOffset + index * this.xScale;\n    }\n  }\n\n  getXRaw( index, optimized ) {\n\n    if ( optimized && this.dataInUse ) {\n      return this.dataInUse.x[ index ];\n    }\n\n    if ( this.xdata ) {\n      return this.xdata.data[ index ];\n    } else {\n      return index;\n    }\n  }\n\n  _integrateP( from = 0, to = this.getLength() - 1 ) {\n\n    from = Math.round( from );\n    to = Math.round( to );\n\n    if ( from > to ) {\n      let temp = from;\n      from = to;\n      to = temp;\n    }\n\n    var l = to - from + 1;\n    var sum = 0,\n      delta;\n\n    let deltaTot = 0;\n    let diff;\n    var arrY = this.getData();\n\n    for ( ; from <= to; from++ ) {\n\n      if ( arrY.length - 1 > from ) {\n        diff = this.getX( from + 1 ) - this.getX( from );\n        deltaTot += diff;\n        sum += arrY[ from ] * diff;\n      }\n    }\n\n    return [ sum, l, deltaTot ];\n  }\n\n  integrateP( from, to ) {\n    var val = this._integrateP( from, to );\n    return val[ 0 ];\n  }\n\n  integrate( fromX, toX ) {\n    return this.integrateP( this.getIndexFromX( fromX ), this.getIndexFromX( toX ) );\n  }\n\n  average( p0 = 0, p1 = this.getLength() - 1 ) {\n    return this.getAverageP( p0, p1 );\n  }\n\n  mean() {\n    return this.average();\n  }\n\n  getAverageP( from, to ) {\n    var sum = this._integrateP( from, to );\n    return sum[ 0 ] / sum[ 2 ];\n  }\n\n  getAverageX( from, to ) {\n    var sum = this._integrateX( from, to );\n    return sum[ 0 ] / sum[ 2 ];\n  }\n\n  checkMonotonicity() {\n\n    let i = 1,\n      data = this.getData();\n    const l = this.data.length;\n    let dir = data[ 1 ] > data[ 0 ];\n\n    for ( ; i < l; i++ ) {\n      if ( data[ i ] !== data[ i - 1 ] && dir !== ( data[ i ] > data[ i - 1 ] ) ) {\n        return this._monotoneous = false;\n      }\n    }\n\n    this._monotoneousAscending = data[ 1 ] > data[ 0 ];\n    return this._monotoneous = true;\n  }\n\n  requireXMonotonicity() {\n    if ( this.xdata ) {\n      this.xdata.requireMonotonicity();\n    }\n  }\n\n  requireMonotonicity() {\n    if ( !this.isMonotoneous() ) {\n      throw \"The wave must be monotonic\";\n    }\n  }\n\n  isMonotoneous() {\n    return !!this._monotoneous;\n  }\n\n  isXMonotoneous() {\n    if ( this.xdata ) {\n      return this.xdata.isMonotoneous();\n    }\n    // Offset and scale is always monotoneous\n    return true;\n  }\n\n  invert( data ) {\n\n    let d = dataY || this.data;\n    d.reverse();\n\n    if ( this.isMonotoneous() ) {\n      this._monotoneousAscending = !this._monotoneousAscending;\n    }\n\n    return d;\n  }\n\n  resampleForDisplay( options ) { // Serie redrawing\n\n    let i = 0;\n\n    this.requireXMonotonicity();\n\n    let inverting = false,\n      dataY = this.getDataY(),\n      data = {\n        x: [],\n        y: []\n      },\n      dataMinMax = [],\n      resampleSum, resampleMin, resampleMax, resampleNum, resample_x_start, resample_x_px_start,\n      x_px,\n      doing_mean = false,\n      firstPointIndex = 0,\n      xval;\n\n    const l = this.getLength();\n\n    if ( !options.xPosition ) {\n      throw \"No position calculation method provided\";\n    }\n\n    if ( !options.resampleToPx ) {\n      throw \"No \\\"resampleToPx\\\" method was provided. Unit: px per point\";\n    }\n\n    if ( options.minX > options.maxX ) {\n      let temp = options.minX;\n      options.minX = options.maxX;\n      options.maxX = temp;\n    }\n\n    if ( ( this.xdata && !this.xdata.getMonotoneousAscending() ) || ( !this.xdata && this.xScale < -0 ) ) {\n      inverting = true;\n      i = l;\n    }\n\n    for ( ; inverting ? i > 0 : i < l; inverting ? i-- : i++ ) {\n\n      xval = this.getX( i );\n\n      if ( options.minX > xval ) {\n\n        firstPointIndex = i;\n        continue;\n      }\n\n      x_px = options.xPosition( xval );\n\n      if ( !doing_mean ) {\n\n        if ( !firstPointIndex ) {\n\n          firstPointIndex = i;\n        } else {\n\n          data.x.push( xval );\n          data.y.push( dataY[ firstPointIndex ] );\n\n        }\n\n        while ( isNaN( dataY[ i ] ) ) {\n\n          if ( inverting ) {\n            i--;\n          } else {\n            i++;\n          }\n        }\n\n        resampleSum = resampleMin = resampleMax = dataY[ firstPointIndex ];\n        resampleNum = 1;\n        resample_x_px_start = x_px;\n        resample_x_start = xval;\n        firstPointIndex = 0;\n\n        doing_mean = true;\n\n        continue;\n      }\n\n      if ( Math.abs( x_px - resample_x_px_start ) > options.resampleToPx || i == l || i == 0 || isNaN( dataY[ i ] ) ) {\n\n        let xpos = ( resample_x_start + xval ) / 2;\n\n        data.x.push( xpos );\n        data.y.push( resampleSum / resampleNum );\n\n        dataMinMax.push( xpos, resampleMin, resampleMax );\n\n        if ( options.maxX !== undefined && xval > options.maxX ) {\n\n          break;\n        }\n\n        doing_mean = false;\n\n        continue;\n      }\n\n      resampleSum += dataY[ i ];\n      resampleNum++;\n\n      resampleMin = Math.min( resampleMin, dataY[ i ] );\n      resampleMax = Math.max( resampleMax, dataY[ i ] );\n    }\n\n    this.dataInUseType = \"resampled\";\n    this.dataInUse = data;\n    return dataMinMax;\n  }\n\n  interpolate( x ) {\n\n    let yData = this.getDataY();\n    let xIndex;\n\n    if ( this.xdata ) {\n      let xData = this.xdata.getData();\n      xIndex = binarySearch( x, xData, !this.xdata.getMonotoneousAscending() );\n      if ( xData[ xIndex ] == x ) {\n        return yData[ xIndex ];\n      }\n      return ( x - xData[ xIndex ] ) / ( xData[ xIndex + 1 ] - xData[ xIndex ] ) * ( yData[ xIndex + 1 ] - yData[ xIndex ] ) + yData[ xIndex ];\n\n    } else {\n      xIndex = ( x - this.xOffset ) / ( this.xScale );\n      let xIndexF = Math.floor( xIndex );\n      return ( xIndex - xIndexF ) * ( yData[ xIndexF + 1 ] - yData[ xIndexF ] ) + yData[ xIndexF ];\n    }\n\n  }\n  \n  interpolateIndex_X( index ) {\n\n    let yData = this.getDataY();\n    if ( this.xdata ) {\n      let xData = this.xdata.getData();\n      let indexStart = Math.floor( index );\n\n      return ( index - indexStart ) * ( xData[ indexStart + 1 ] - xData[ indexStart ] ) + xData[ indexStart ];\n    }\n  }\n\n  getMonotoneousAscending() {\n\n    if ( !this.isMonotoneous() ) {\n      return \"The waveform is not monotoneous\";\n    }\n\n    return this._monotoneousAscending;\n  }\n\n  getXMonotoneousAscending() {\n    if ( this.xdata ) {\n      return this.xdata.getMonotoneousAscending();\n    }\n\n    return this.xScale > 0;\n  }\n\n  isXMonotoneousAscending() {\n    return this.getXMonotoneousAscending( ...arguments );\n  }\n\n  divide( numberOrWave ) {\n    return this._arithmetic( numberOrWave, DIVIDE );\n  }\n\n  divideBy() {\n    return this.divide( ...arguments );\n  }\n\n  multiply( numberOrWave ) {\n    return this._arithmetic( numberOrWave, MULTIPLY );\n  }\n\n  multiplyBy() {\n    return this.multiply( ...arguments );\n  }\n\n  log() {\n    return this.logBase( 10 );\n  }\n\n  ln() {\n    return this.logBase( Math.E )\n  }\n\n  logBase( base ) {\n\n    let logBase = Math.log( base );\n    this.data.map( ( valY ) => {\n\n      return Math.log( valY ) / logBase;\n    } )\n  }\n\n  add( numberOrWave ) {\n    return this._arithmetic( numberOrWave, ADD );\n  }\n\n  addBy() {\n    return this.add( ...arguments );\n  }\n\n  subtract( numberOrWave ) {\n    return this._arithmetic( numberOrWave, SUBTRACT );\n  }\n\n  subtractBy() {\n    return this.subtract( ...arguments );\n  }\n\n  math( method ) {\n\n    for ( var i = 0; i < this.getLength(); i++ ) {\n      this.data[ i ] = method( this.getY( i ), this.getX( i ) );\n    }\n\n    this._setData( this.data );\n    return this;\n  }\n\n  _arithmetic( numberOrWave, operator ) {\n\n    if ( numberOrWave instanceof Waveform ) {\n      return this._waveArithmetic( numberOrWave, operator );\n    } else if ( typeof numberOrWave == 'number' ) {\n\n      return this._numberArithmetic( numberOrWave, operator );\n    }\n  }\n\n  _numberArithmetic( num, operation ) {\n\n    let i = 0,\n      l = this.getLength();\n\n    if ( operation == MULTIPLY ) {\n\n      for ( ; i < l; i++ ) {\n        this.data[ i ] *= num;\n      }\n\n      this.minY *= num;\n      this.maxY *= num;\n    } else if ( operation == DIVIDE ) {\n\n      for ( ; i < l; i++ ) {\n        this.data[ i ] /= num;\n      }\n\n      this.minY /= num;\n      this.maxY /= num;\n    } else if ( operation == ADD ) {\n\n      for ( ; i < l; i++ ) {\n        this.data[ i ] += num;\n      }\n\n      this.minY += num;\n      this.maxY += num;\n    } else if ( operation == SUBTRACT ) {\n\n      for ( ; i < l; i++ ) {\n        this.data[ i ] -= num;\n      }\n\n      this.minY -= num;\n      this.maxY -= num;\n    }\n\n    return this;\n  }\n\n  _waveArithmetic( wave, operation ) {\n\n    let yDataThis = this.getDataY(),\n\n      i = 0;\n    const l = this.getLength();\n    this.requireXMonotonicity();\n    wave.requireXMonotonicity();\n\n    if ( operation == MULTIPLY ) {\n\n      for ( ; i < l; i++ ) {\n        yDataThis[ i ] *= wave.interpolate( this.getX( i ) );\n      }\n    } else if ( operation == DIVIDE ) {\n\n      for ( ; i < l; i++ ) {\n        yDataThis[ i ] /= wave.interpolate( this.getX( i ) );\n      }\n    } else if ( operation == ADD ) {\n\n      for ( ; i < l; i++ ) {\n        yDataThis[ i ] += wave.interpolate( this.getX( i ) );\n      }\n    } else if ( operation == SUBTRACT ) {\n\n      for ( ; i < l; i++ ) {\n        yDataThis[ i ] -= wave.interpolate( this.getX( i ) );\n      }\n    }\n\n    this._setData( yDataThis );\n    return this;\n  }\n\n  aggregate( direction = 'x' ) {\n\n    this._dataAggregating = {};\n    this._dataAggregated = {};\n    this._dataAggregationDirection = direction.toUpperCase();\n\n    var pow2 = pow2floor( this.getLength() );\n\n    this._dataAggregating = aggregator( {\n\n      minX: this.minX,\n      maxX: this.maxX,\n      minY: this.minY,\n      maxY: this.maxY,\n      data: this.data,\n      xdata: this.xdata ? this.xdata.getData() : undefined,\n      xScale: this.xScale,\n      xOffset: this.xOffset,\n      numPoints: pow2,\n      direction: direction\n\n    } ).then( ( event ) => {\n\n      this._dataAggregated = event.aggregates;\n      this._dataAggregating = false;\n    } );\n\n  }\n\n  hasAggregation() {\n    return !!this._dataAggregated;\n  }\n\n  selectAggregatedData( pxWidth ) {\n\n    if ( pxWidth < 2 ) {\n      return false;\n    }\n    /*\n    console.log( direction, this._dataAggregationDirection );\n\n        if( direction !== this._dataAggregationDirection ) {\n          throw \"The data is not aggregated in that direction\";\n        }\n    */\n\n    var level = pow2ceil( pxWidth );\n\n    if ( this._dataAggregated[ level ] ) {\n\n      this.dataInUseType = \"aggregate\" + this._dataAggregationDirection;\n      this.dataInUse = this._dataAggregated[ level ];\n      return;\n    } else if ( this._dataAggregating ) {\n\n      return this._dataAggregating;\n    }\n\n    this.dataInUseType = \"none\";\n    this.dataInUse = {\n      y: this.data,\n      x: this.getXWaveform().data\n    };\n  }\n\n  duplicate( alsoDuplicateXWave ) {\n    var newWaveform = new Waveform();\n    newWaveform._setData( this.getDataY().slice() );\n    newWaveform.rescaleX( this.xOffset, this.xShift );\n    newWaveform.setShift( this.getShift() );\n    newWaveform.setScale( this.getScale() );\n\n    if ( this.xdata ) {\n      if ( alsoDuplicateXWave ) {\n        newWaveform.setXWaveform( this.xdata.duplicate() );\n      } else {\n        newWaveform.setXWaveform( this.xdata );\n      }\n\n      newWaveform.setXShift( this.getXShift() );\n      newWaveform.setXScale( this.getXScale() );\n\n    } else {\n      newWaveform.xOffset = this.xOffset;\n      newWaveform.xScale = this.xScale;\n    }\n\n    return newWaveform;\n  }\n\n  subrangeX( fromX, toX ) {\n\n    if ( !this.xdata ) { // We can select the new range from there\n\n      let fromP = this.getIndexFromX( fromX ),\n        toP = this.getIndexFromX( toP );\n\n      return new Waveform()\n        .setData( this.data.slice( fromP, toP ) )\n        .rescaleX( this.xOffset, this.xScale );\n\n    } else {\n\n      var waveform = new Waveform();\n\n      for ( var i = 0, l = this.data.length; i < l; i++ ) {\n\n        if ( this.data[ i ] >= fromX && this.data[ i ] < toX ) {\n\n          waveform.append( this.dataX[ i ], this.data[ i ] )\n        }\n      }\n\n      return waveform;\n    }\n  }\n\n  findLocalMinMax( xRef, xWithin, type ) {\n\n    let index = this.getIndexFromX( xRef ),\n      indexPlus = this.getIndexFromX( xRef + xWithin ),\n      indexMinus = this.getIndexFromX( xRef - xWithin );\n\n    return this.findLocalMinMaxIndex( indexMinus, indexPlus, type );\n  }\n\n  findLocalMinMaxIndex( indexMinus, indexPlus, type ) {\n\n    let tmp;\n\n    if ( indexPlus < indexMinus ) {\n      tmp = indexPlus;\n      indexPlus = indexMinus;\n      indexMinus = tmp;\n    }\n\n    let curr, currI;\n\n    if ( type == 'max' ) {\n\n      curr = Number.NEGATIVE_INFINITY;\n\n      for ( var i = indexMinus; i <= indexPlus; i++ ) {\n\n        if ( this.getY( i ) > curr ) {\n          curr = this.getY( i );\n          currI = i;\n        }\n      }\n    } else {\n\n      curr = Number.POSITIVE_INFINITY;\n\n      for ( var i = indexMinus; i <= indexPlus; i++ ) {\n\n        if ( this.getY( i ) < curr ) {\n          curr = this.getY( i );\n          currI = i;\n        }\n      }\n    }\n\n    if ( currI == indexMinus || currI == indexPlus ) {\n      return false;\n    }\n\n    return this.getX( currI );\n  }\n\n  warn( text ) {\n    if ( console ) {\n      console.warn( text );\n    }\n  }\n\n  setUnit( unit ) {\n    this.unit = unit;\n    return this;\n  }\n\n  setXUnit( unit ) {\n    if ( this.hasXWaveform() ) {\n      this.xdata.setUnit( unit );\n    }\n\n    this.xunit = unit;\n    return this;\n  }\n\n  getUnit() {\n    return this.unit || \"\";\n  }\n\n  getXUnit() {\n    if ( this.hasXWaveform() ) {\n      return this.xdata.getUnit();\n    }\n\n    return this.xunit | \"\";\n  }\n\n  hasXUnit() {\n    return this.getXUnit().length > 0;\n  }\n\n  hasUnit() {\n    return this.getUnit().length > 0;\n  }\n\n  findLevels( level, options ) {\n\n    options = extend( {\n\n      box: 1,\n      edge: 'both',\n      rounding: 'before',\n      rangeP: [ 0, this.getLength() ],\n\n    }, options );\n\n    var lastLvlIndex = options.rangeP[ 0 ];\n    var lvlIndex;\n    var indices = [];\n    var i = 0;\n\n    while ( lvlIndex = this.findLevel( level, extend( true, {}, options, {\n        rangeP: [ lastLvlIndex, options.rangeP[ 1 ] ]\n      } ) ) ) {\n      indices.push( lvlIndex );\n      lastLvlIndex = Math.ceil( lvlIndex );\n\n      i++;\n      if ( i > 1000 ) {\n        return;\n      }\n    }\n\n    return indices;\n  }\n\n  // Find the first level in the specified range\n  findLevel( level, options ) {\n\n    options = extend( {\n\n      box: 1,\n      edge: 'both',\n      direction: 'ascending',\n      rounding: 'before',\n      rangeP: [ 0, this.getLength() ],\n\n    }, options );\n\n    if ( options.rangeX ) {\n      options.rangeP = options.rangeX.map( this.getIndexFromX );\n    }\n\n    var value,\n      below,\n      i,\n      j,\n      l,\n      increment;\n\n    var box = options.box;\n\n    if ( box % 2 == 0 ) {\n      box++;\n    }\n\n    if ( options.direction == \"descending\" ) {\n      i = options.rangeP[ 1 ],\n        l = options.rangeP[ 0 ],\n        increment = -1;\n    } else {\n      i = options.rangeP[ 0 ],\n        l = options.rangeP[ 1 ],\n        increment = +1;\n    }\n\n    for ( ;; i += increment ) {\n\n      if ( options.direction == \"descending\" ) {\n        if ( i < l ) {\n          break;\n        }\n      } else {\n        if ( i > l ) {\n          break;\n        }\n      }\n\n      if ( i < options.rangeP[ 0 ] + ( box - 1 ) / 2 ) {\n        continue;\n      }\n\n      if ( i > options.rangeP[ 1 ] - ( box - 1 ) / 2 ) {\n        break;\n      }\n\n      value = this.getAverageP( i - ( box - 1 ) / 2, i + ( box - 1 ) / 2 );\n\n      if ( below === undefined ) {\n        below = value < level;\n        continue;\n      }\n      // Crossing up\n      if ( value >= level && below ) {\n\n        below = false;\n\n        if ( options.edge == 'ascending' || options.edge == 'both' ) {\n          // Found something\n\n          for ( j = i + ( box - 1 ) / 2; j >= i - ( box - 1 ) / 2; j-- ) {\n\n            if ( this.data[ j ] >= level && this.data[ j - 1 ] <= level ) { // Find a crossing\n\n              switch ( options.rounding ) {\n                case 'before':\n                  return j - 1;\n                  break;\n\n                case 'after':\n                  return j;\n                  break;\n\n                case 'interpolate':\n                  return getIndexInterpolate( level, this.data[ j ], this.data[ j - 1 ], j, j - 1 );\n                  break;\n              }\n            }\n          }\n        }\n\n      } else if ( value <= level && !below ) {\n\n        below = true;\n\n        if ( options.edge == 'descending' ||  options.edge == 'both' ) {\n\n          for ( j = i + ( box - 1 ) / 2; j >= i - ( box - 1 ) / 2; j-- ) {\n\n            if ( this.data[ j ] <= level && this.data[ j - 1 ] >= level ) { // Find a crossing\n\n              switch ( options.rounding ) {\n                case 'before':\n                  return j - 1;\n                  break;\n\n                case 'after':\n                  return j;\n                  break;\n\n                case 'interpolate':\n                  return getIndexInterpolate( level, this.data[ j ], this.data[ j - 1 ], j, j - 1 );\n                  break;\n              }\n\n            }\n          }\n        }\n      }\n    }\n  }\n\n  normalize( mode ) {\n\n    let factor,\n      total,\n      minValue,\n      maxValue,\n      ratio,\n      i;\n\n    if ( mode == 'max1' || mode == 'max100' ) {\n\n      factor = 1;\n\n      if ( mode == 'max100' ) {\n        factor = 100;\n      }\n\n      maxValue = this.data[ 0 ];\n\n      for ( i = 1; i < this.getLength(); i++ ) {\n\n        if ( this.data[ i ] > maxValue ) {\n\n          maxValue = this.data[ i ];\n        }\n      }\n\n      for ( i = 0; i < this.getLength(); i++ ) {\n\n        this.data[ i ] /= maxValue / factor;\n      }\n\n    } else if ( mode == 'sum1' ) {\n\n      total = 0;\n\n      for ( i = 0; i < this.getLength(); i++ ) {\n        total += this.data[ i ];\n      }\n\n      for ( i = 0; i < this.getLength(); i++ ) {\n\n        this.data[ i ] /= total;\n      }\n\n    } else if ( mode == 'max1min0' ) {\n\n      maxValue = this.data[ 0 ],\n        minValue = this.data[  0 ];\n\n      for ( i = 1; i < this.getLength(); i++ ) {\n        if ( this.data[ i ] > maxValue ) {\n\n          maxValue = this.data[ i ]\n\n        } else if ( this.data[ i ] < minValue ) {\n\n          minValue = this.data[ i ];\n\n        }\n      }\n\n      ratio = 1 / ( maxValue - minValue );\n\n      for ( i = 0; i < this.getLength(); i++ ) {\n\n        this.data[ i ] = ( this.data[ i ] - minValue ) * ratio;\n      }\n\n    }\n\n    this.setData( this.data );\n  }\n\n};\n\nconst MULTIPLY = Symbol();\nconst ADD = Symbol();\nconst SUBTRACT = Symbol();\nconst DIVIDE = Symbol();\n\n// http://stackoverflow.com/questions/26965171/fast-nearest-power-of-2-in-javascript\nfunction pow2ceil( v ) {\n  v--;\n  var p = 2;\n  while ( ( v >>= 1 ) ) {\n    p <<= 1;\n  }\n  return p;\n}\n\nfunction pow2floor( v ) {\n\n  var p = 1;\n\n  while ( ( v >>= 1 ) ) {\n    p <<= 1;\n\n  }\n  return p;\n}\n\nfunction getIndexInterpolate( value, valueBefore, valueAfter, indexBefore, indexAfter ) {\n  return ( value - valueBefore ) / ( valueAfter - valueBefore ) * ( indexAfter - indexBefore ) + indexBefore;\n}\n\nfunction binarySearch( target, haystack, reverse ) {\n\n  let seedA = 0,\n    length = haystack.length,\n    seedB = ( length - 1 ),\n    seedInt,\n    i = 0,\n    nanDirection = 1;\n\n  if ( haystack[ seedA ] == target ) {\n    return seedA;\n  }\n\n  if ( haystack[ seedB ] == target ) {\n    return seedB;\n  }\n\n  while ( true ) {\n    i++;\n    if ( i > 100 ) {\n      throw \"Error loop\";\n    }\n\n    seedInt = Math.floor( ( seedA + seedB ) / 2 );\n\n    //  seedInt -= seedInt % 2; // Always looks for an x.\n\n    while ( isNaN( haystack[ seedInt ] ) ) {\n\n      if ( seedInt >= haystack.length - 1 ) {\n\n        return haystack.length - 1;\n\n      } else if ( seedInt <= 0 ) {\n\n        return 0;\n      }\n\n      seedInt += nanDirection;\n    }\n\n    if ( seedInt == seedA || haystack[ seedInt ] == target || seedInt == seedB ) {\n      return seedInt;\n    }\n\n    //    console.log(seedA, seedB, seedInt, haystack[seedInt]);\n    if ( haystack[ seedInt ] <= target ) {\n      if ( reverse ) {\n        seedB = seedInt;\n      } else {\n        seedA = seedInt;\n      }\n    } else if ( haystack[ seedInt ] > target ) {\n      if ( reverse ) {\n        seedA = seedInt;\n      } else {\n        seedB = seedInt;\n      }\n    } else {\n      return false;\n    }\n\n    nanDirection *= -1;\n  }\n}\n\nexport default Waveform"],"names":["FitHost","options","DELTAP","BIGVAL","WEIGHT","setYData","dataY","setXData","dataX","setWeight","weight","setInitialParams","params","subsetIndex","setSubset","setFunction","function","progress","hookIteration","data","parms","map","el","NPARMS","length","fromIndex","toIndex","undefined","_from","_to","f","_hookIteration","buildFit","func","_func","NPTS","getLength","arrY","getDataY","arrX","getDataX","resid","Array","fill","jac","log","join","LM","_result","done","x","param","sumsq","i","message","dp","j","computeResiduals","delta","FACTOR","d","k","nudge","getResidualElement","xmin","getMin","xmax","getMax","index","fit","l","waveformResult","waveform","setData","gH","gnadj","gnpnts","hook","LMITER","LMBOOST","LMSHRINK","LAMBDAZERO","LAMBDAMAX","LMTOL","sos","sosprev","lambda","myH","nadj","npts","beta","alpha","amatrix","niter","bLMiter","error","buildJacobian","getJacobianElement","rrise","gaussj","q","a","N","det","big","save","L","ik","jk","Math","abs","Waveform","xOffset","xScale","isArray","y","forEach","push","setXWaveform","newData","_makeArray","warnNaN","nanable","isNaNAllowed","warn","_setData","optimized","dataInUse","getScale","getShift","xdata","computeXMinMax","wave","append","getX","offset","scale","_typedArrayClass","constructor","getTypedArrayClass","name","isUnsigned","from","hasXWaveform","getXWaveform","setTypedArrayClass","Float32Array","Float64Array","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","minX","maxX","minY","maxY","prepend","unshift","recalculateMinMaxNewPoint","monotoneous","getMonotoneousAscending","_monotoneousAscending","monoDir","_monotoneous","min","max","b1","b2","val","useDataToUse","roundingMethod","round","position","getIndexFromData","dataInUseType","xval","getData","valCollection","isAscending","isMonotoneous","trace","binarySearch","getXScale","getXShift","shift","setShift","setScale","arr","self","Promise","resolver","rejector","FitLM","extend","results","init","to","temp","sum","deltaTot","diff","_integrateP","fromX","toX","integrateP","getIndexFromX","p0","p1","getAverageP","average","_integrateX","dir","requireMonotonicity","reverse","requireXMonotonicity","inverting","dataMinMax","resampleSum","resampleMin","resampleMax","resampleNum","resample_x_start","resample_x_px_start","x_px","doing_mean","firstPointIndex","xPosition","resampleToPx","isNaN","xpos","yData","xIndex","xData","xIndexF","floor","indexStart","getXMonotoneousAscending","arguments","numberOrWave","_arithmetic","DIVIDE","divide","MULTIPLY","multiply","logBase","E","base","valY","ADD","add","SUBTRACT","subtract","method","getY","operator","_waveArithmetic","_numberArithmetic","num","operation","yDataThis","interpolate","direction","_dataAggregating","_dataAggregated","_dataAggregationDirection","toUpperCase","pow2","pow2floor","aggregator","then","event","aggregates","pxWidth","level","pow2ceil","alsoDuplicateXWave","newWaveform","slice","rescaleX","xShift","duplicate","setXShift","setXScale","fromP","toP","xRef","xWithin","type","indexPlus","indexMinus","findLocalMinMaxIndex","tmp","curr","currI","Number","NEGATIVE_INFINITY","POSITIVE_INFINITY","text","console","unit","setUnit","xunit","getUnit","getXUnit","lastLvlIndex","rangeP","lvlIndex","indices","findLevel","ceil","rangeX","value","below","increment","box","edge","rounding","getIndexInterpolate","mode","factor","total","minValue","maxValue","ratio","Symbol","v","p","valueBefore","valueAfter","indexBefore","indexAfter","target","haystack","seedA","seedB","seedInt","nanDirection"],"mappings":"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"}